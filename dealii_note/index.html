<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Yi's Website</title><meta name="author" content="Yi Qiu"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Yi's Website</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/research"> Research Experiences</a></li><li class="menus_item"><a class="site-page" href="/Blogs-Notes"> Blogs</a></li><li class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://imqiuyi.com/arXiv Daily/"> ArXiv Notes</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/ME.JPG" onerror="this.onerror=null;this.src='/img/ME.JPG'" alt="avatar"></div><div class="author-discrip"><h3>Yi Qiu</h3><p class="author-bio">Research assistant in School of Astronomy &amp; Space Science in Nanjing University.</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-links"><li><a class="e-social-link" href="mailto:yiqiu@nju.edu.cn" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i><span>yiqiu@nju.edu.cn</span></a></li></ul></div><a class="cv-links" href="/attaches/curriculum-vitae.pdf" target="_blank"><i class="fas fa-file-pdf" aria-hidden="true"><span>My CV</span></i></a></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title"></h2><article><h2 id="Basic-concept"><a href="#Basic-concept" class="headerlink" title="Basic concept"></a>Basic concept</h2><p>To define the shape functions, we need the following:</p>
<ul>
<li>A mesh on which to define shape functions. You have already seen how to generate and manipulate the objects that describe meshes in step-1 and step-2.</li>
<li>A finite element that describes the shape functions we want to use on the reference cell (which in deal.II is always the unit interval $[0,1]$, the unit square $[0,1]^{2}$ or the unit cube $[0,1]^{3}$, depending on which space dimension you work in). In step-2, we had already used an object of type $F E_{1} Q<2>$, which denotes the usual Lagrange elements that define shape functions by interpolation on support points The simplest one is FE_Q $2&gt;(1)$, which uses polynomial degree 1. In 2d, these are often referred to as bilinear, since they are linear in each of the two coordinates of the reference cell. (In $1 d$, they would be linear and in $3 \mathrm{~d}$ tri-linear, however, in the deal.II documentation, we will frequently not make this distinction and simply always call these functions “linear”.)</li>
<li>A DoFHandler object that enumerates all the degrees of freedom on the mesh, taking the reference cell description the finite element object provides as the basis. You’ve also already seen how to do this in step-2.</li>
<li>A mapping that tells how the shape functions on the real cell are obtained from the shape functions defined by the finite element class on the reference cell. By default, unless you explicitly say otherwise, deal.II will use a (bi-, tri-)linear mapping for this, so in most cases you don’t have to worry about this step.</li>
</ul>
<p>Define the dimension specifically:</p>
<p> <code>Triangulation&lt;3&gt;</code> or  <code>Triangulation&lt;2&gt;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>Function</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>triangulation</td>
<td>store the grid information overall (cells)</td>
<td>hyper_cube</td>
</tr>
<tr>
<td>DoFHandler</td>
<td>distribute information to the finite element</td>
<td>FE_Q</td>
</tr>
<tr>
<td>sparsity_pattern</td>
<td>corresponding to the matrix</td>
<td>dynamic_sparsity_pattern</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/classMappingQ1.html">MappingQ1</a></td>
<td>map the quadrature points to the matrix</td>
<td>QGauss</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/classFEValues.html">FEValues</a></td>
<td>store the sum over quadrature points</td>
<td></td>
</tr>
<tr>
<td>solver.solve(system_matrix, solution, system_rhs, <a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/classPreconditionIdentity.html">PreconditionIdentity</a>())</td>
<td>solve the linear equation</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/classFunction.html">Function</a></td>
<td>the template of functions</td>
<td>Wavefunction</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a></td>
<td>local integrators related to $L^2$-inner products</td>
<td>mass matrix for scalar or vector values finite elements: <script type="math/tex">\int_{Z} (u v) dx \quad \text { or } \quad \int_{Z} \mathbf{u} \cdot \mathbf{v} d x</script></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>The basic class <a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/classFunction.html">Function</a>, which declares the common interface which all functions have to follow, would concrete classes that overload the <code>value</code> function, which takes a point in dim-dimensional space as parameters and returns the value at that point as a <code>double</code> variable. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span><span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp; p,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundaryValues</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span><span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp; p,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In essence, what is happening here is that <a target="_blank" rel="noopener" href="https://www.dealii.org/current/doxygen/deal.II/classFunction.html">Function</a> is an “abstract” base class that declares a certain “interface” – a set of functions one can call on objects of this kind. But it does not actually <em>implement</em> these functions: it just says “this is how Function objects look like”, but what kind of function it actually is, is left to derived classes that implement the <code>value()</code> function.</p>
<h2 id="Solve-the-wave-equation"><a href="#Solve-the-wave-equation" class="headerlink" title="Solve the wave equation"></a>Solve the wave equation</h2><p>The wave equation in its prototypical form reads as follows: find $u(x, t), x \in \Omega, t \in[0, T]$ that satisfies</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial^{2} u}{\partial t^{2}}-\Delta u &=f & & \text { in } \Omega \times[0, T] \\
u(x, t) &=g & & \text { on } \partial \Omega \times[0, T] \\
u(x, 0) &=u_{0}(x) & & \text { in } \Omega \\
\frac{\partial u(x, 0)}{\partial t} &=u_{1}(x) & & \text { in } \Omega
\end{aligned}</script><p>Note that since this is an equation with second-order time derivatives, we need to pose two initial conditions, one for the value and one for the time derivative of the solution. </p>
<h5 id="Rothe’s-method"><a href="#Rothe’s-method" class="headerlink" title="Rothe’s method"></a>Rothe’s method</h5><p>Given these considerations, here is how we will proceed: let us first define a simple time stepping method for this second order problem, and then in a second step do the spatial discretization, i.e. we will follow Rothe’s approach.</p>
<p>For the first step, let us take a little detour first: in order to discretize a second time derivative, we can either discretize it directly, or we can introduce an additional variable and transform the system into a first order system. In many cases, this turns out to be equivalent, but dealing with first order systems is often simpler. To this end, let us introduce</p>
<script type="math/tex; mode=display">
v=\frac{\partial u}{\partial t},</script><p>and call this variable the velocity for obvious reasons. We can then reformulate the original wave equation as follows:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial u}{\partial t}-v &=0 & & \text { in } \Omega \times[0, T], \\
\frac{\partial \nu}{\partial t}-\Delta u &=f & & \text { in } \Omega \times[0, T], \\
u(x, t) &=g & & \text { on } \partial \Omega \times[0, T], \\
u(x, 0) &=u_{0}(x) & & \text { in } \Omega, \\
v(x, 0) &=u_{1}(x) & & \text { in } \Omega .
\end{aligned}</script><p>The advantage of this formulation is that it now only contains first time derivatives for both variables, for which it is simple to write down time stepping schemes. Note that we do not have boundary conditions for $v$ at first. However, we could enforce $v=\frac{\partial g}{\partial t}$ on the boundary. It turns out in numerical examples that this is actually necessary: without doing so the solution doesn’t look particularly wrong, but the CrankNicolson scheme does not conserve energy if one doesn’t enforce these boundary conditions.<br>With this formulation, let us introduce the following time discretization where a superscript $n$ indicates the number of a time step and $k=t<em>{n}-t</em>{n-1}$ is the length of the present time step:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{u^{n}-u^{n-1}}{k}-\left[\theta v^{n}+(1-\theta) v^{n-1}\right]=0, \\
&\frac{v^{n}-v^{n-1}}{k}-\Delta\left[\theta u^{n}+(1-\theta) u^{n-1}\right]=\theta f^{n}+(1-\theta) f^{n-1} .
\end{aligned}</script><p>Note how we introduced a parameter $\theta$ here. If we chose $\theta=0$, for example, the first equation would reduce to $\frac{u^{n}-u^{n-1}}{k}-v^{n-1}=0$, which is well-known as the forward or explicit Euler method. On the other hand, if we set $\theta=1$, then we would get $\frac{u^{n}-u^{n-1}}{k}-v^{n}=0$, which corresponds to the backward or implicit Euler method. Both these methods are first order accurate methods. They are simple to implement, but they are not really very accurate.</p>
<p><u>The third case would be to choose $\theta=\frac{1}{2}$. The first of the equations above would then read $\frac{u^{n}-u^{n-1}}{k}-\frac{1}{2}\left[v^{n}+v^{n-1}\right]=0$. This method is known as the Crank-Nicolson method and has the advantage that it is second order accurate. In addition, it has the nice property that it preserves the energy in the solution</u> (physically, the energy is the sum of the kinetic energy of the particles in the membrane plus the potential energy present due to the fact that it is locally stretched; this quantity is a conserved one in the continuous equation, but most time stepping schemes do not conserve it after time discretization). Since $v^{n}$ also appears in the equation for $u^{n}$, the Crank-Nicolson scheme is also implicit.<br>In the program, we will leave $\theta$ as a parameter, so that it will be easy to play with it. The results section will show some numerical evidence comparing the different schemes.<br>The equations above (called the semidiscretized equations because we have only discretized the time, but not space), can be simplified a bit by eliminating $v^{n}$ from the first equation and rearranging terms. We then get</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left[1-k^{2} \theta^{2} \Delta\right] u^{n} &=\left[1+k^{2} \theta(1-\theta) \Delta\right] u^{n-1}+k v^{n-1}+k^{2} \theta\left[\theta f^{n}+(1-\theta) f^{n-1}\right] \\
v^{n} &=v^{n-1}+k \Delta\left[\theta u^{n}+(1-\theta) u^{n-1}\right]+k\left[\theta f^{n}+(1-\theta) f^{n-1}\right]
\end{aligned}</script><p>In this form, we see that if we are given the solution $u^{n-1}, v^{n-1}$ of the previous timestep, that we can then solve for the variables $u^{n}, v^{n}$ separately, i.e. one at a time. This is convenient. In addition, we recognize that the operator in the first equation is positive definite, and the second equation looks particularly simple.</p>
<h5 id="Space-discretization"><a href="#Space-discretization" class="headerlink" title="Space discretization"></a>Space discretization</h5><p>We have now derived equations that relate the approximate (semi-discrete) solution $u^{n}(x)$ and its time derivative $v^{n}(x)$ at time $t<em>{n}$ with the solutions $u^{n-1}(x), v^{n-1}(x)$ of the previous time step at $t</em>{n-1}$. The next step is to also discretize the spatial variable using the usual finite element methodology. To this end, we multiply each equation with a test function, integrate over the entire domain, and integrate by parts where necessary. This leads to</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left(u^{n}, \varphi\right)+k^{2} \theta^{2}\left(\nabla u^{n}, \nabla \varphi\right) &=\left(u^{n-1}, \varphi\right)-k^{2} \theta(1-\theta)\left(\nabla u^{n-1}, \nabla \varphi\right)+k\left(v^{n-1}, \varphi\right)+k^{2} \theta\left[\theta\left(f^{n}, \varphi\right)+(1-\theta)\left(f^{n-1}, \varphi\right)\right], \\
\left(v^{n}, \varphi\right) &=\left(v^{n-1}, \varphi\right)-k\left[\theta\left(\nabla u^{n}, \nabla \varphi\right)+(1-\theta)\left(\nabla u^{n-1}, \nabla \varphi\right)\right]+k\left[\theta\left(f^{n}, \varphi\right)+(1-\theta)\left(f^{n-1}, \varphi\right)\right] .
\end{aligned}</script><p>It is then customary to approximate $u^{n}(x) \approx u<em>{h}^{n}(x)=\sum</em>{i} U<em>{i}^{n} \phi</em>{i}^{n}(x)$, where $\phi<em>{i}^{n}(x)$ are the shape functions used for the discretization of the $n$-th time step and $U</em>{i}^{n}$ are the unknown nodal values of the solution. Similarly, $v^{n}(x) \approx v<em>{h}^{n}(x)=\sum</em>{i} V<em>{i}^{n} \phi</em>{i}^{n}(x)$. Finally, we have the solutions of the previous time $\operatorname{step}, u^{n-1}(x) \approx u<em>{h}^{n-1}(x)=\sum</em>{i} U<em>{i}^{n-1} \phi</em>{i}^{n-1}(x)$ and $v^{n-1}(x) \approx v<em>{h}^{n-1}(x)=\sum</em>{i} V<em>{i}^{n-1} \phi</em>{i}^{n-1}(x)$. Note that since the solution of the previous time step has already been computed by the time we get to time step $n, U^{n-1}, V^{n-1}$ are known. Furthermore, note that the solutions of the previous step may have been computed on a different mesh, so we have to use shape functions $\phi_{i}^{n-1}(x)$.<br>If we plug these expansions into above equations and test with the test functions from the present mesh, we get the following linear system:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left(M^{n}+k^{2} \theta^{2} A^{n}\right) U^{n} &=M^{n, n-1} U^{n-1}-k^{2} \theta(1-\theta) A^{n, n-1} U^{n-1}+k M^{n, n-1} V^{n-1}+k^{2} \theta\left[\theta F^{n}+(1-\theta) F^{n-1}\right], \\
M^{n} V^{n} &=M^{n, n-1} V^{n-1}-k\left[\theta A^{n} U^{n}+(1-\theta) A^{n, n-1} U^{n-1}\right]+k\left[\theta F^{n}+(1-\theta) F^{n-1}\right],
\end{aligned}</script><p>where</p>
<script type="math/tex; mode=display">
\begin{aligned}
M_{i j}^{n} &=\left(\phi_{i}^{n}, \phi_{j}^{n}\right), \\
A_{i j}^{n} &=\left(\nabla \phi_{i}^{n}, \nabla \phi_{j}^{n}\right), \\
M_{i j}^{n, n-1} &=\left(\phi_{i}^{n}, \phi_{j}^{n-1}\right), \\
A_{i j}^{n, n-1} &=\left(\nabla \phi_{i}^{n}, \nabla \phi_{j}^{n-1}\right), \\
F_{i}^{n} &=\left(f^{n}, \phi_{i}^{n}\right), \\
F_{i}^{n-1} &=\left(f^{n-1}, \phi_{i}^{n}\right) .
\end{aligned}</script><p>If we solve these two equations, we can move the solution one step forward and go on to the next time step.</p>
<p>It is worth noting that if we choose the same mesh on each time step (as we will in fact do in the program below), then we have the same shape functions on time step $n$ and $n-1$, i.e. $\phi<em>{i}^{n}=\phi</em>{i}^{n-1}=\phi_{i}$. Consequently, we get $M^{n}=M^{n, n-1}=M$ and $A^{n}=A^{n, n-1}=A$. On the other hand, if we had used different shape functions, then we would have to compute integrals that contain shape functions defined on two meshes. This is a somewhat messy process that we omit here, but that is treated in some detail in step-28.</p>
<h2 id="Files-output-and-slicing"><a href="#Files-output-and-slicing" class="headerlink" title="Files output and slicing"></a>Files output and slicing</h2><p>A senior graduate student (Chengjiang Yin) in our NJU FEM-NR group has establish a python script (almost a package) to automatically slice the data and save them in .csv files for efficiently ploting..</p>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/research"> Research Experiences</a></li><li class="nav_item"><a class="nav-page" href="/Blogs-Notes"> Blogs</a></li><li class="nav_item"><a class="nav-page" target="_blank" rel="noopener" href="https://imqiuyi.com/arXiv Daily/"> ArXiv Notes</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2020 - 2021 by Yi Qiu</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>